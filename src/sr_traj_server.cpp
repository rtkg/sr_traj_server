/**
 * @file   sr_traj_server.cpp
 * @author Robert Krug
 * @date   Fri Feb 24, 2012
 *
 */

#include <ros/ros.h>
#include <string>
#include "sr_traj_server/sr_traj_server.h"
#include <sr_robot_msgs/sendupdate.h>
#include <sr_robot_msgs/joint.h>


const unsigned int TrajectoryServer::number_hand_joints_ = 20;

TrajectoryServer::TrajectoryServer() : nh_private_("~")
{

    std::string param;
    std::string traj_dir;
    nh_private_.searchParam("trajectory_dir", param);
    nh_private_.param(param, traj_dir, std::string());
    trajectory_parser_ = new TrajectoryParser(traj_dir);
    
    ROS_INFO("Trajectory directory set to: %s", traj_dir.c_str());

    std::string prefix;
    nh_private_.searchParam("sendupdate_prefix", param);
    nh_private_.param(param, prefix, std::string());

    // std::string full_topic = prefix + "/raw/joint_states";
    // cyberglove_jointstates_sub_ = node_.subscribe(full_topic, 10, &TrajectoryServer::jointStatesCallback, this);

    // nh_private_.searchParam("remapper_prefix", searched_param);
    // nh_private_.param(searched_param, prefix, std::string());
    // full_topic = prefix + "project_eigenspace";
    // project_eigenspace_service_ = node_.advertiseService(full_topic,&TrajectoryServer::formProjMatrix,this);
   
    // nh_private_.searchParam("sendupdate_prefix", searched_param);
    // nh_private_.param(searched_param, prefix, std::string());
    // full_topic = prefix + "sendupdate";
    // shadowhand_pub_ = node_.advertise<sr_robot_msgs::sendupdate> (full_topic, 5);
}

TrajectoryServer::~TrajectoryServer(){delete trajectory_parser_;}


 //  Eigen::VectorXd TrajectoryServer::getRemappedVector(std::vector<double> const & glove_values)
// {
//   Eigen::VectorXd joint_angles(number_hand_joints_);

//   //The following corresponds to the linear regression approach by UHAM; The alpha-beta-gamma values
//   //are read from abg.txt, the gains are read from gains.txt. Both aforementioned files are
//   //generated by the UHAM Java Calibration Routine which utilizes GraspIt using the
//   //ShadowhandLast.xml model;

// //  The joints of the actual CR5 muscle platform 
// //   0..90   distal joint / FFJ1 MFJ1 RFJ1 LFJ1  (underactuated from J2)
// //   0..90   medial joint / FFJ2 MFJ2 RFJ2 LFJ2  (also controlling J1)
// //   0..90   proximal joint / FFJ3 MFJ4 RFJ3 LFJ3
// // -25..25   abduction joint FFJ4 MFJ4 RFJ4 LFJ4
// //   0..40   palm-arch joint / LFJ5

// // -10..90   thumb distal flex / THJ1
// // -30..30   thumb medial flex / thJ2
// // -15..15   thumb medial abduction / THJ3
// //   0..75   thumb base flex THJ4
// // -60..60   thumb base rotation THJ5

//   joint_angles[0]=linRegression(17,glove_values[2],0); //ThumbPI_DIJ - THJ1
//   joint_angles[1]=linRegression(16,glove_values[1],0);//ThumbMPJ - THJ2
//   joint_angles[2]=linRegression(15,glove_values[1],glove_values[3]); //ThumbProxLat (coupled with ThumbAb) - THJ3
//   joint_angles[3]=linRegression(14,glove_values[3],0); //ThumbAb - THJ4 
//   joint_angles[4]=linRegression(13,glove_values[0],0); //ThumbRotate - THJ5
//   joint_angles[5]=linRegression(12,(2*glove_values[5]+glove_values[6])/3,0)*2; //IndexPI-DIJ - FFJ0; couple PI-DIJ sensor readings (factor 2 is necessary to get correct joint targets)
//   joint_angles[6]=linRegression(11,glove_values[4],0);//IndexMPJ - FFJ3
//   joint_angles[7]=linRegression(10,glove_values[10],0);//IndexAb - FFJ4; 
//   joint_angles[8]=linRegression(9,(2*glove_values[8]+glove_values[9])/3,0)*2;//MiddlePI-DIJ -MFJ0; couple PI-DIJ sensor readings (factor 2 is necessary to get correct joint targets)
//   joint_angles[9]=linRegression(8,glove_values[7],0);//MiddleMPJ - MFJ3
//   joint_angles[10]=linRegression(7,glove_values[14],0);//MiddleAb - MFJ4; 
//   joint_angles[11]=linRegression(6,(2*glove_values[12]+glove_values[13])/3,0)*2;//RingPI-DIJ - RFJ0; couple PI-DIJ sensor readings (factor 2 is necessary to get correct joint targets)
//   joint_angles[12]=linRegression(5,glove_values[11],0);//RingMPJ - RFJ3
//   joint_angles[13]=-linRegression(4,glove_values[18],glove_values[14]);//RingAb (coupled with PinkieAb) - RFJ4; signs need to be switched
//   joint_angles[14]=linRegression(3,(2*glove_values[16]+glove_values[17])/3,0)*2;//PinkiePI-DIJ - LFJ0; couple PI-DIJ sensor readings (factor 2 is necessary to get correct joint targets)
//   joint_angles[15]=linRegression(2,glove_values[15],0);//PinkieMPJ - LFJ3
//   joint_angles[16]=-linRegression(1,glove_values[18],glove_values[14]);//PinkieAb (coupled with MiddleAb) - LFJ4; signs need to be switched;
//   joint_angles[17]=linRegression(0,glove_values[19],0);//PinkiePalm - LFJ5
//   joint_angles[18]=linWristMapping("G_WristPitch",glove_values[20]); //WRJ1
//   joint_angles[19]=linWristMapping("G_WristYaw",glove_values[21]); //WRJ2

//   projectOnEspace(joint_angles);
  
//   //Check the joint limits - probably superfluous since they get checked in Shadow's code anyway
//   joint_angles[0]=checkJointLimits(joint_angles[0],0,90); //THJ1
//   joint_angles[1]=checkJointLimits(joint_angles[1],-30,30);//THJ2
//   joint_angles[2]=checkJointLimits(joint_angles[2],-15,15); //THJ3
//   joint_angles[3]=checkJointLimits(joint_angles[3],0,75); //THJ4
//   joint_angles[4]=checkJointLimits(joint_angles[4],-60,60); //THJ5
//   joint_angles[5]=checkJointLimits(joint_angles[5],0,180); //FFJ0
//   joint_angles[6]=checkJointLimits(joint_angles[6],0,90);// FFJ3
//   joint_angles[7]=checkJointLimits(joint_angles[7],-25,25);//FFJ4; range in GraspIt is +/-5
//   joint_angles[8]=checkJointLimits(joint_angles[8],0,180);//MFJ0
//   joint_angles[9]=checkJointLimits(joint_angles[9],0,90);//MFJ3
//   joint_angles[10]=checkJointLimits(joint_angles[10],-25,25);//MFJ4; range in GraspIt is +/-5
//   joint_angles[11]=checkJointLimits(joint_angles[11],0,180);//RFJ0
//   joint_angles[12]=checkJointLimits(joint_angles[12],0,90);//RFJ3
//   joint_angles[13]=checkJointLimits(joint_angles[13],-25,25);//RFJ4; range in GraspIt is +/-5
//   joint_angles[14]=checkJointLimits(joint_angles[14],0,180);//LFJ0; 
//   joint_angles[15]=checkJointLimits(joint_angles[15],0,90);//LFJ3
//   joint_angles[16]=checkJointLimits(joint_angles[16],-25,25);//LFJ4; range in GraspIt is +10/-25
//   joint_angles[17]=checkJointLimits(joint_angles[17],0,40);//LFJ5
//   joint_angles[18]=checkJointLimits(joint_angles[18],-35,45);//WRJ1
//   joint_angles[19]=checkJointLimits(joint_angles[19],-30,10);//WRJ2

//   return joint_angles;
// }
// void TrajectoryServer::jointStatesCallback( const sensor_msgs::JointStateConstPtr& msg )
// {
//     sr_robot_msgs::joint joint;
//     sr_robot_msgs::sendupdate pub;

//     //Do conversion
//     Eigen::VectorXd vect = getRemappedVector(msg->position);
//     //Generate sendupdate message
//     pub.sendupdate_length = number_hand_joints_;

//     std::vector<sr_robot_msgs::joint> table(number_hand_joints_);
//     for(int i = 0; i < number_hand_joints_; ++i )
//     {
//         joint.joint_name = joints_names_[i];
//         joint.joint_target = vect(i);
//         table[i] = joint;
//     }
//     pub.sendupdate_length = number_hand_joints_;
//     pub.sendupdate_list = table;
//     shadowhand_pub_.publish(pub);
// }


